#Kolmogorov forward equation 
# Function to define the drift and diffusion coefficients
d <- function(x, t) {
  # Example drift (replace with your specific function)
  return(x)
}

b <- function(x, t) {
  # Example diffusion coefficient (replace with your specific function)
  return(1)  # Constant diffusion
}

# Function to implement the finite difference scheme
fd_solve <- function(x_grid, dt, dx, initial_condition) {
  n_steps <- length(dt)
  n_grid <- length(x_grid)
  
  # Initialize probability density at each grid point and time step
  P <- matrix(0, nrow = n_grid, ncol = n_steps)
  P[ , 1] <- initial_condition(x_grid)  # Set initial condition
  
  # Boundary conditions (replace with your specific conditions)
  P[1, ] <- 0  # Reflective boundary at x_min
  P[n_grid, ] <- 0  # Reflective boundary at x_max
  
  # Finite difference scheme
  for (i in 2:n_steps) {
    for (j in 2:(n_grid - 1)) {
      dP_dt <- -(d(x_grid[j], dt[i-1]) * (P[j, i-1] - P[j-1, i-1]) / dx + 
                0.5 * b(x_grid[j], dt[i-1])^2 * (P[j+1, i-1] - 2*P[j, i-1] + P[j-1, i-1]) / dx^2)
      P[j, i] <- P[j, i-1] + dP_dt * dt[i-1]
    }
  }
  
  return(P)
}

# Example usage (replace with your specific problem setup)
x_min <- 0
x_max <- 10
n_grid <- 100
dx <- (x_max - x_min) / (n_grid - 1)
x_grid <- seq(from = x_min, to = x_max, by = dx)

dt <- 0.1  # Time step
n_steps <- 10  # Number of time steps

# Define initial condition (replace with your specific function)
initial_condition <- function(x) {
  if (x >= 5 && x <= 7) {
    return(1)
  } else {
    return(0)
  }
}

# Solve the FKE
P <- fd_solve(x_grid, dt, dx, initial_condition)
# Plot the solution at different time steps
library(ggplot2)

time_steps <- seq(1, n_steps, by = 5)
ggplot() +
  geom_line(aes(x = x_grid, y = P[, 1]), linetype = "dashed", color = "gray") +  # Initial condition
  geom_line(aes(x = x_grid, y = P[, time_steps[1]]), color = "blue") +
  geom_line(aes(x = x_grid, y = P[, time_steps[2]]), color = "green") +
  geom_line(aes(x = x_grid, y = P[, time_steps[3]]), color = "red") +
  labs(x = "x", y = "Probability Density", title = "Kolmogorov Forward Equation Solution")

# expected time to kit state k of a Markov jump process 

# Function to calculate expected reach time
expected_reach_time <- function(transition_matrix, initial_state, target_state) {
  n_states <- nrow(transition_matrix)
  
  # Initialize first passage times (time to reach target state for the first time)
  first_passage_time <- rep(Inf, n_states)
  first_passage_time[target_state] <- 0  # Reaching target state from itself takes 0 time
  
  # Iteration to calculate first passage times
  has_changed <- TRUE
  while (has_changed) {
    has_changed <- FALSE
    for (i in 1:n_states) {
      if (first_passage_time[i] == Inf) next
      for (j in 1:n_states) {
        if (j != target_state && transition_matrix[i, j] > 0) {
          new_time <- first_passage_time[i] + 1 / transition_matrix[i, j]
          if (new_time < first_passage_time[j]) {
            first_passage_time[j] <- new_time
            has_changed <- TRUE
          }
        }
      }
    }
  }
  
  # Check if target state is reachable from initial state
  if (first_passage_time[initial_state] == Inf) {
    return(NA)  # Target state not reachable
  }
  
  return(first_passage_time[initial_state])
}

# Example usage
transition_matrix <- matrix(c(0.4, 0.3, 0.3, 0.2, 0.5, 0.3, 0.1, 0.7, 0.2), nrow = 3, byrow = TRUE)
initial_state <- 1
target_state <- 3

expected_time <- expected_reach_time(transition_matrix, initial_state, target_state)

if (!is.na(expected_time)) {
  cat("Expected time to reach state", target_state, "from state", initial_state, ":", expected_time)
} else {
  cat("State", target_state, "is not reachable from state", initial_state)
}

# verifying if a Brownian motion is a martingale 

# Function to simulate Brownian motion path
brownian_motion <- function(n_steps, sigma) {
  # Generate standard normal random variables
  dW <- rnorm(n_steps, mean = 0, sd = sqrt(1/n_steps))
  
  # Simulate Brownian motion path with drift (set to 0 for standard BM)
  W <- cumsum(sigma * dW)
  return(W)
}

# Function to calculate expected value at future time step
expected_value <- function(W, t, future_step) {
  n <- length(W)
  if (future_step > n) {
    stop("Future step exceeds path length")
  }
  return(mean(W[1:(n - future_step)]))
}

# Simulation parameters
n_steps <- 1000
sigma <- 0.2

# Simulate Brownian motion path
W <- brownian_motion(n_steps, sigma)

# Check martingale property at different future time steps
future_steps <- c(10, 50, 100)
for (step in future_steps) {
  E_t <- expected_value(W, step = step)
  W_future <- W[step + 1]
  cat("Future step:", step, ", E[W_t] ~=", E_t, ", W_(t+1)=", W_future, "\n")
}

